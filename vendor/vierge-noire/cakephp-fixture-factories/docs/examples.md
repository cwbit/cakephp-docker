<h1 align="center">Test Fixtures</h1>

Here are some examples of how to use the fixture factories.

One article with a random title, as defined in the factory [on the previous page](factories.md):
```php
$article = ArticleFactory::make()->getEntity();
```
Two articles with different random titles:
```php
$articles = ArticleFactory::make(2)->getEntities();
```
One article with title set to 'Foo':
```php
$article = ArticleFactory::make(['title' => 'Foo'])->getEntity();
```
Three articles with the title set to 'Foo':
```php
$articles = ArticleFactory::make(['title' => 'Foo'], 3)->getEntities();
```
or
```php
$articles = ArticleFactory::make(3)->patchData(['title' => 'Foo'])->getEntities();
```
or
```php
$articles = ArticleFactory::make(3)->setField('title', 'Foo')->getEntities();
```
or
```php
$articles = ArticleFactory::make()->setField('title', 'Foo')->setTimes(3)->getEntities();
```
or
```php
$articles = ArticleFactory::make([
 ['title' => 'Foo'],
 ['title' => 'Bar'],
 ['title' => 'Baz'],
])->getEntities();
```

In order to persist the data generated, use the method `persist` instead of `getEntity` resp. `getEntities`:
```php
$articles = ArticleFactory::make(3)->persist();
```

Do not forget to check the [plugin's tests](../tests) for
more insights!

### Using `FactoryAwareTrait`
All examples above are using static getter to fetch a factory instance. As convenience and kinda syntactic sugar, you can use the `FactoryAwareTrait::getFactory` instead.

`getFactory` is more tolerant on provided name, as you can use plurals or lowercased names. All arguments passed after factory name will be cast to `BaseFactory::make`.

```php
use App\Test\Factory\ArticleFactory;
use CakephpFixtureFactories\Factory\FactoryAwareTrait;

class MyTest extends TestCase
{
    use FactoryAwareTrait;

    public function myTest(): void
    {
        // Static getter style
        $article = ArticleFactory::make()->getEntity();
        $article = ArticleFactory::make(['title' => 'Foo'])->getEntity();
        $articles = ArticleFactory::make(3)->getEntities();
        $articles = ArticleFactory::make(['title' => 'Foo'], 3)->getEntities();

        // Exactly the same in FactoryAwareTrait style
        $article = $this->getFactory('Article')->getEntity();
        $article = $this->getFactory('Article', ['title' => 'Foo'])->getEntity();
        $articles = $this->getFactory('Article', 3)->getEntities();
        $articles = $this->getFactory('Article', ['title' => 'Foo'], 3)->getEntities();
    }
}
```

### Chaining methods
The aim of the test fixture factories is to bring business coherence in your test fixtures.
This can be simply achieved using the chainable methods of your factories. As long as those return `$this`, you may chain as much methods as you require.
In the following example, we make use of a method in the Article factory in order to easily create articles with a job title.
It is a simple study case, but this could be any pattern of your business logic.
```php
$articleFactory = ArticleFactory::make(['title' => 'Foo']);
$articleFoo1 = $articleFactory->persist();
$articleFoo2 = $articleFactory->persist();
$articleJobOffer = $articleFactory->setJobTitle()->persist();
```

 The two first articles have a title set two 'Foo'. The third one has a job title, which is randomly generated by fake, as defined in the
 `ArticleFactory`.

### With a callable

In case a given field has not been specified with `faker` in the `setDefaultTemplate` method,  all the generated fields of a given factory
will be identical. The following
generates three articles with different random titles:
```php
use App\Test\Factory\ArticleFactory;
use Faker\Generator;
...
$articles = ArticleFactory::make(function(ArticleFactory $factory, Generator $faker) {
   return [
       'title' => $faker->text,
   ];
}, 3)->persist();
```
